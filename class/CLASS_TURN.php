<?php
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// ***************************************************************
// CLASS_TURN.php
// ***************************************************************
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

//////////////////////////////////////////////////////////////////
// TURN クラス
// スレッドの表示順を記録したファイルを管理するクラス
//////////////////////////////////////////////////////////////////
class TURN {
    //************************************************************
    // メンバ変数
    protected $flag_exist;  // 保存ファイルが存在しているか
    protected $data;        // 順番データ
    protected $size;        // データの数
    protected $path;        // 保存ファイルのパス

    //************************************************************
    // 以下、メソッド

    //////////////////////////////////////////////////////////////
    // コンストラクタ
    //////////////////////////////////////////////////////////////
    // 引数   : $p   : 読み込むデータのパス
    // 戻り値 : 無し
    //////////////////////////////////////////////////////////////
    public function TURN( $p = NULL ) {
        // メンバ変数の初期化
        $this->flag_exist = false;
        $this->data = NULL;
        $this->size = 0;
        $this->path = NULL;

        // 引数としてファイルパスが与えられていれば、
        // ここで順番データを読み込む
        if ( $p != NULL ) {
            $this->path = $p;
            if ( file_exists($p) ) {
                $this->flag_exist = true;
                $this->data       = file($p);
                $this->size       = count( $this->data );
            }
        }
    }

    //////////////////////////////////////////////////////////////
    // ファイルの有無を返す
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : $file_exist : ファイルの有無をbool値で返す
    //////////////////////////////////////////////////////////////
    public function getExist() {
        return $this->flag_exist;
    }

    //////////////////////////////////////////////////////////////
    // ファイルのサイズを返す
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : $size : スレッドの数を返す
    //////////////////////////////////////////////////////////////
    public function getSize() {
        return $this->size;
    }

    //////////////////////////////////////////////////////////////
    // スレッド表示のループ上限値を返す
    //////////////////////////////////////////////////////////////
    // 引数   : $start : 何番目から数えるかを表す数値
    // 引数   : $limit : ループ回数の上限値(デフォルトは10)
    // 戻り値 : $cnt   : ループ上限値
    //////////////////////////////////////////////////////////////
    public function getLoopLimit($start = 0,$limit = 10) {
        // $startから数えて、スレッドは残り何個あるのかを計算
        $left = $this->size - $start;

        if ( $left > $limit ) {
            // 残りのスレッド数が$limitを越えていれば$limitにあわせる
            $cnt = $start + $limit;
        } else {
            // 越えていなければ$leftにあわせる
            $cnt = $start + $left;
        }
        return $cnt;
    }

    //////////////////////////////////////////////////////////////
    // 順番データの中身を返す
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : $data : 順場データ
    //////////////////////////////////////////////////////////////
    public function getData() {
        return $this->data;
    }

    //////////////////////////////////////////////////////////////
    // 順番データの値を１つ返す
    //////////////////////////////////////////////////////////////
    // 引数   : $pos   : 参照する順番の位置
    // 戻り値 : $value : 参照された位置の値
    //////////////////////////////////////////////////////////////
    public function getValue($pos = 0) {
        if ( $pos < 0 || $this->size <= $pos ) {
            return NULL;
        }
        return intval($this->data[$pos]);
    }

    //////////////////////////////////////////////////////////////
    // 順番データの最大値を１つ返す
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : $value : データの中の最大値
    //////////////////////////////////////////////////////////////
    public function getMaxValue() {
        return intval(max($this->data));
    }

    //////////////////////////////////////////////////////////////
    // 順番データに新規追加を行う
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : 無し
    //////////////////////////////////////////////////////////////
    public function addData() {

        // データが空なら配列として初期化しておく
        if ( $this->data == NULL ) {
            $this->data = array();
            $new_data = 1;
        }
        else {
            $new_data = max($this->data) + 1;
        }

        array_unshift( $this->data, $new_data );
        $this->size++;
        return;
    }

    //////////////////////////////////////////////////////////////
    // 順番データの指定したデータを削除する
    // 削除というよりは対象データを省いて再構成するイメージ
    //////////////////////////////////////////////////////////////
    // 引数   : $delete_no : 削除する対象の順番データ番号
    // 戻り値 : 無し
    //////////////////////////////////////////////////////////////
    public function deleteData($delete_no) {
        $no = intval($delete_no);
        // 空の配列を用意
        $temp = array();
        foreach($this->data as $value ) {
            // 削除対象のデータなら無視する
            if ( $value == $no ) { continue; }
            // そうでなければ配列に突っ込む
            array_push($temp,$value);
        }
        $this->data = $temp;

        // データ数を再設定
        $this->size = count($this->data);
    }

    //////////////////////////////////////////////////////////////
    // 順番データを保存する
    //////////////////////////////////////////////////////////////
    // 引数   : 無し
    // 戻り値 : $res : 成否をbool値で返す
    //////////////////////////////////////////////////////////////
    public function writeData() {
        if ( $this->path == NULL | $this->path == "" ) {
            // 保存先の指定が無ければ論外
            $res = false;
        } else {
            // 配列データを1つの文字列に変換
            $temp = "";
            for($i=0;$i<$this->size;$i++) {
                if ( $i > 0 ) { $temp .= "\n"; }
                $temp .= intval(trim($this->data[$i]));
            }
            // ファイル保存
            $fp = fopen($this->path,"w");
            flock($fp,LOCK_EX);
            fwrite($fp, $temp );
            flock($fp,LOCK_UN);
            fclose($fp);
            $res = true;
        }
        return $res;
    }

    //////////////////////////////////////////////////////////////
    // 選択されたスレッドNoを順番データの一番上に移動させる
    //////////////////////////////////////////////////////////////
    // 流れとしては空の配列を作って、一番上に持ってきたい
    // スレッドNoを先にいれておく。
    // そして、それ以外のスレッドNoを上から順番にいれていく。
    //////////////////////////////////////////////////////////////
    // 引数   : $no : 一番上に移動させる対象のスレッドNo
    // 戻り値 : 無し
    //////////////////////////////////////////////////////////////
    public function upSelectedTurn($no = NULL) {
        if ( !is_numeric($no) )  {
            die("TURN->upSelectedTurn() : ".MESSAGE_WRONG_VALUE."(" . $no . ")");
        }

        $no = intval($no);
        $temp = array($no);
        foreach($this->data as $value ) {
            if ( $value == $no ) { continue; }
            array_push($temp,$value);
        }

        $this->data = $temp;
        return;
    }

}

?>